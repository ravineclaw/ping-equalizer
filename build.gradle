import net.ravenclaw.StringObfuscatorPlugin

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.4.1'
    }
}

plugins {
    id 'fabric-loom' version '1.13.6'
    id 'maven-publish'
}

// Apply the string obfuscation plugin
apply plugin: net.ravenclaw.StringObfuscatorPlugin

// Configure string obfuscation based on build task
// Default: disabled (plain strings for development)
stringObfuscation {
    // Enabled when:
    // 1. -PobfuscateStrings is passed
    // 2. buildObfuscated task is run
    // 3. buildAggressive task is run
    // 4. runClient task is run
    enabled = project.hasProperty('obfuscateStrings') || gradle.startParameter.taskNames.any { taskName ->
        taskName == 'buildObfuscated' || taskName == 'buildAggressive' || taskName == 'buildAgressive' || taskName == 'obfuscateJar' || taskName == 'runClient'
    }
}

version = project.mod_version
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

loom {
    mixin {
        defaultRefmapName = "ravenclawspingequalizer.refmap.json"
        useLegacyMixinAp = true
    }
}

afterEvaluate {
    loom {
        runs {
            client {
                source "build/libs/${project.archives_base_name}-${project.version}-obf.jar"
            }
        }
    }
}


repositories {
}

dependencies {
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
}

task generatePrivateKey {
    def outputDir = file("build/generated/sources/key/java")
    outputs.dir outputDir
    
    doLast {
        def secretsFile = file("secrets.properties")
        def privateKey = ""
        if (secretsFile.exists()) {
            def props = new Properties()
            secretsFile.withInputStream { props.load(it) }
            privateKey = props.getProperty("modPrivateKey", "")
        } else {
            println "secrets.properties not found, using dummy key"
            privateKey = "DUMMY_KEY"
        }

        // Split into 32 shards with advanced obfuscation
        def shards = []
        def chunkSize = (int) Math.ceil(privateKey.length() / 32.0)
        
        // Rotation keys for advanced obfuscation (same as in PrivateKeyReconstructor)
        def rotationKeys = [0x5A, 0x3C, 0x7B, 0x1E, 0x4F, 0x9D, 0x2B, 0x8C,
                           0x6E, 0xA1, 0x3F, 0xD2, 0x59, 0x87, 0xC3, 0x14] as int[]
        int rotKeyLen = rotationKeys.size()
        
        for (int i = 0; i < 32; i++) {
            int start = i * chunkSize
            int end = Math.min(start + chunkSize, privateKey.length())
            String chunk = (start < end) ? privateKey.substring(start, end) : ""
            
            // XOR Obfuscation with primary key (0x2A = 42)
            char[] chars = chunk.toCharArray()
            for (int j = 0; j < chars.length; j++) {
                int charInt = (int) chars[j]
                chars[j] = (char) (charInt ^ 0x2A)
            }
            
            // XOR with rotation key for additional security
            for (int j = 0; j < chars.length; j++) {
                int keyIndex = (j + i) % rotKeyLen
                int charInt = (int) chars[j]
                chars[j] = (char) (charInt ^ rotationKeys[keyIndex])
            }
            
            shards.add(new String(chars))
        }

        def encoder = java.util.Base64.getEncoder()
        def shardLiterals = shards.collect { "\"${encoder.encodeToString(it.getBytes('UTF-8'))}\"" }
                                  .join(",\n        ")

        def packageDir = file("${outputDir}/net/ravenclaw/ravenclawspingequalizer/cryptography")
        packageDir.mkdirs()
        def outputFile = file("${packageDir}/PrivateKeyStorage.java")

        def content = """package net.ravenclaw.ravenclawspingequalizer.cryptography;

/**
 * Securely stores the private key in distributed obfuscated shards.
 * Note: Crypto is disabled at runtime, but shards remain available for future use.
 */
public final class PrivateKeyStorage {
    private static final String[] SHARDS = new String[] {
        ${shardLiterals}
    };

    private PrivateKeyStorage() {}

    /**
     * Retrieves the shard array for reconstruction.
     * @return Array of obfuscated shards
     */
    public static String[] getShards() {
        return SHARDS.clone();
    }

    /**
     * Gets a specific shard by index.
     * @param index Shard index (0-31)
     * @return Encrypted shard string
     */
    public static String getShard(int index) {
        if (index < 0 || index >= SHARDS.length) {
            return "";
        }
        return SHARDS[index];
    }

    /**
     * Gets total number of shards.
     * @return Number of shards
     */
    public static int getShardCount() {
        return SHARDS.length;
    }
}
"""
        outputFile.text = content
    }
}

compileJava.dependsOn generatePrivateKey
afterEvaluate {
    tasks.named("sourcesJar") { 
        dependsOn generatePrivateKey
        dependsOn 'generateObfuscatedStrings'
    }
}
sourceSets.main.java.srcDir "build/generated/sources/key/java"

processResources {
    inputs.property "version", project.version
    inputs.property "minecraft_version", project.minecraft_version
    inputs.property "loader_version", project.loader_version
    filteringCharset "UTF-8"

    filesMatching("fabric.mod.json") {
        expand "version": project.version,
                "minecraft_version": project.minecraft_version,
                "loader_version": project.loader_version
    }
}

def targetJavaVersion = 21
tasks.withType(JavaCompile).configureEach {
    it.options.encoding = "UTF-8"
    if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
        it.options.release.set(targetJavaVersion)
    }
}

java {
    def javaVersion = JavaVersion.toVersion(targetJavaVersion)
    if (JavaVersion.current() < javaVersion) {
        toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
    }
    withSourcesJar()
}

jar {
    from("LICENSE") {
        rename { "${it}_${project.archivesBaseName}" }
    }
}
publishing {
    publications {
        create("mavenJava", MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }

    repositories {
    }
}

task obfuscateJar(type: proguard.gradle.ProGuardTask) {
    dependsOn tasks.remapJar
    
    // Input: The remapped jar
    injars tasks.remapJar.archiveFile
    
    // Output: The obfuscated jar
    outjars layout.buildDirectory.file("libs/${project.archives_base_name}-${project.version}-obf.jar")
    
    // Libraries
    libraryjars sourceSets.main.compileClasspath
    libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod"
    libraryjars "${System.getProperty('java.home')}/jmods/java.desktop.jmod"
    libraryjars "${System.getProperty('java.home')}/jmods/java.logging.jmod"
    
    // Target Java 21 - forces ProGuard to generate proper stackmap frames
    target '21'

    configuration 'proguard.conf'
}

task buildAggressive {
    dependsOn build
    dependsOn obfuscateJar
}

// Backwards-compatible alias for the commonly mistyped task name
tasks.register("buildAgressive") {
    group = 'build'
    description = 'Alias for buildAggressive'
    dependsOn buildAggressive
}

// ============================================================================
// BUILD TASKS SUMMARY:
// ============================================================================
// ./gradlew build              - Normal build, NO string obfuscation (development)
// ./gradlew buildObfuscated    - Build with string obfuscation enabled
// ./gradlew buildAggressive    - Build with string obfuscation + ProGuard
// ============================================================================

task buildObfuscated {
    description = 'Build with compile-time string obfuscation enabled'
    group = 'build'
    
    doFirst {
        // Force regeneration with obfuscation
        project.delete("build/generated/sources/strings")
    }
    
    dependsOn build
}

// Clean generated sources when doing a full clean
clean.doFirst {
    delete "build/generated/sources/strings"
}

// ============================================================================
// CRYPTO TEST TASKS
// ============================================================================

task runTestServer(type: JavaExec) {
    description = 'Run the crypto test server'
    group = 'verification'
    
    classpath = sourceSets.test.runtimeClasspath + sourceSets.main.runtimeClasspath
    mainClass = 'net.ravenclaw.ravenclawspingequalizer.cryptography.CryptoTestServer'
    
    standardInput = System.in
    
    dependsOn testClasses
}

task runTestClient(type: JavaExec) {
    description = 'Run the crypto test client'
    group = 'verification'
    
    classpath = sourceSets.test.runtimeClasspath + sourceSets.main.runtimeClasspath
    mainClass = 'net.ravenclaw.ravenclawspingequalizer.cryptography.CryptoTestClient'
    
    standardInput = System.in
    
    dependsOn testClasses
}

task launch {
    description = 'Build with obfuscation and launch the Minecraft client'
    group = 'fabric'

    dependsOn buildAggressive
    dependsOn 'runClient'
}
