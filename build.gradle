buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.4.1'
    }
}

plugins {
    id 'fabric-loom' version '1.13.6'
    id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

loom {
    mixin {
        defaultRefmapName = "ravenclawspingequalizer.refmap.json"
        useLegacyMixinAp = true
    }
}


repositories {
}

dependencies {
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
}

task generatePrivateKey {
    def outputDir = file("build/generated/sources/key/java")
    outputs.dir outputDir
    
    doLast {
        def secretsFile = file("secrets.properties")
        def privateKey = ""
        if (secretsFile.exists()) {
            def props = new Properties()
            secretsFile.withInputStream { props.load(it) }
            privateKey = props.getProperty("modPrivateKey", "")
        } else {
            println "secrets.properties not found, using dummy key"
            privateKey = "DUMMY_KEY"
        }

        // Split and Obfuscate
        def shards = []
        def chunkSize = (int) Math.ceil(privateKey.length() / 20.0)
        for (int i = 0; i < 20; i++) {
            int start = i * chunkSize
            int end = Math.min(start + chunkSize, privateKey.length())
            String chunk = (start < end) ? privateKey.substring(start, end) : ""
            
            // XOR Obfuscation
            char[] chars = chunk.toCharArray()
            for (int j = 0; j < chars.length; j++) {
                chars[j] = (char) (chars[j] ^ 42)
            }
            shards.add(new String(chars))
        }

        def packageDir = file("${outputDir}/net/ravenclaw/ravenclawspingequalizer/cryptography")
        packageDir.mkdirs()
        def outputFile = file("${packageDir}/PrivateKey.java")
        
        def content = """package net.ravenclaw.ravenclawspingequalizer.cryptography;

public class PrivateKey {
    // Generated by build.gradle
"""
        for (int i = 0; i < 20; i++) {
            content += "    private static final String S${String.format('%02d', i+1)} = \"${shards[i].replace('\\', '\\\\').replace('"', '\\"')}\";\n"
        }
        
        content += """
    public static String getPrivateKey() {
        StringBuilder sb = new StringBuilder();
"""
        for (int i = 0; i < 20; i++) {
            content += "        sb.append(deobfuscate(S${String.format('%02d', i+1)}));\n"
        }
        content += """        return sb.toString();
    }

    private static String deobfuscate(String encrypted) {
        if (encrypted == null || encrypted.isEmpty()) return "";
        char[] chars = encrypted.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            chars[i] = (char) (chars[i] ^ 42);
        }
        return new String(chars);
    }
}
"""
        outputFile.text = content
    }
}

compileJava.dependsOn generatePrivateKey
afterEvaluate {
    tasks.named("sourcesJar") { dependsOn generatePrivateKey }
}
sourceSets.main.java.srcDir "build/generated/sources/key/java"

processResources {
    inputs.property "version", project.version
    inputs.property "minecraft_version", project.minecraft_version
    inputs.property "loader_version", project.loader_version
    filteringCharset "UTF-8"

    filesMatching("fabric.mod.json") {
        expand "version": project.version,
                "minecraft_version": project.minecraft_version,
                "loader_version": project.loader_version
    }
}

def targetJavaVersion = 21
tasks.withType(JavaCompile).configureEach {
    it.options.encoding = "UTF-8"
    if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
        it.options.release.set(targetJavaVersion)
    }
}

java {
    def javaVersion = JavaVersion.toVersion(targetJavaVersion)
    if (JavaVersion.current() < javaVersion) {
        toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
    }
    withSourcesJar()
}

jar {
    from("LICENSE") {
        rename { "${it}_${project.archivesBaseName}" }
    }
}
publishing {
    publications {
        create("mavenJava", MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }

    repositories {
    }
}

task obfuscateJar(type: proguard.gradle.ProGuardTask) {
    dependsOn tasks.remapJar
    
    // Input: The remapped jar
    injars tasks.remapJar.archiveFile
    
    // Output: The obfuscated jar
    outjars layout.buildDirectory.file("libs/${project.archives_base_name}-${project.version}-obf.jar")
    
    // Libraries
    libraryjars sourceSets.main.compileClasspath
    libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod"
    libraryjars "${System.getProperty('java.home')}/jmods/java.desktop.jmod"
    libraryjars "${System.getProperty('java.home')}/jmods/java.logging.jmod"
    
    configuration 'proguard.conf'
}

task buildAggressive {
    dependsOn build
    dependsOn obfuscateJar
}

